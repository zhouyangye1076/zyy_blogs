# 处理器验证与处理器模糊测试（三）

之后，本文将介绍处理器模糊测试领域近年来有代表性 paper 的创新点和解决思路，帮助读者厘清学术界处理器模糊测试领域的发展脉络。

## RFUZZ

RFUZZ 发表于 ICCAD 2018，是近来学术界处理器模糊测试领域的滥觞之作。该论文将软件的模糊测试技术迁移到了硬件测试领域，针对硬件特性设计了对应的 MUX SELECTOR 覆盖率插桩，并移植 AFL 设计对应的二进制突变技术。此外，RFUZZ 构造 FPGA 模糊测试平台，对模糊测试进行硬件加速，适用于所有的数字电路。

![RFUZZ title](img/rfuzz_title.png)

### 覆盖率指标和覆盖率插桩

为了衡量模糊测试的质量，我们需要对硬件的覆盖率指标进行设计。在上一篇文章中我们介绍了传统的硬件覆盖率指标，如行覆盖率、分支覆盖率、状态机覆盖率等。这些覆盖率大多借鉴软件软件覆盖率的设计方法，与抽象的 Verilog 语句相关联，更适用于仿真测试的场景，这导致如下两个缺点：
* 对底层 RTL 单元的反映不够直接充分
* 覆盖率指标不可综合（难以综合），无法运用于硬件加速的测试场景

数字电路的电信号可以分为数据信号和控制信号两部分，控制信号指的就是各个 MUX 单元的 SELECTOR 信号，可以反映有限状态机的状态变化、数据的选择等信息，在设计思路上和传统覆盖率中的分支覆盖率有异曲同工之妙。因此 RFUZZ 使用数字电路中的各个 MUX 的 SELECTOR 的值作为覆盖率：
* 对于每个 1 位 MUX，SELECTOR = 0/1，共 2 个 coverage
* 对于每个 N 位 MUX，可以看作 $2^N - 1$ 个 MUX 的组合，共 $2^{N-1} - 2$ 个 coverage
* 每个 SELECTOR 的覆盖率相互独立，N 个 1 位 MUX，共 2N 个 coverage

RFUZZ 在 Chisel 编译阶段从 Verilog 层面对代码进行覆盖率插桩。RFUZZ 会对将每个 MUX 的 SELECTOR 接入一个 Coverage 记数单元，根据 SELECTOR 的值变化统计 CoverageSum，并且各个子部分的 CoverageSum 汇总到顶层得到总体的 CoverageSum。类似于如下的实现：

![RFUZZ MUX 覆盖率插桩](img/rfuzz-mux-cov.png)

**优点**：MUX SELECTOR 覆盖率和 RTL 单元紧密关联，直观反映了数字电路的执行状态，并且便于生成可综合的覆盖率插桩，从而可以结合 FPGA 进行覆盖率测量的硬件加速。

<span id="rfuzz-cover-shortcoming">**缺点**：</span>
MUX SELECTOR 用单个 SELECOTR 的值作为一个覆盖点，只反映了数字电路局部的覆盖情况，但是没有反映数字电路整体的覆盖情况。例如对于一个二位的 MUX SELECTOR，每个 SELECTOR 有 0/1 两种情况，当 MUX 遍历 01 和 10 两种情况后所有的覆盖点都被覆盖了，这样就将对 00 和 11 这两种覆盖点的探索排除在外。这是该覆盖率指标在设计之初就没能覆盖到的情况，需要设计覆盖范围更全面的指标来加以解决。

### 输入接口和二进制突变

为了进行模糊测试，我们需要设计测试样例生成和突变机制。RFUZZ 借鉴 AFL 设计了硬件的二进制生成和突变技术。

我们首先介绍 RFUZZ AFL 突变算法的输入定义：对于输入为 N 位的数字电路，我们需要检测该电路在 K 个时钟周期内的执行结果是否总是正确；因为数字电路每个周期有对应的 N 位输入，所以该数字电路需要接受 K 组 N 位输入，也就是长度为 KN 的二进制序列。如下图的 DUT 每周期接受 66(32+32+1+1) bit 的输入，共执行 4 个周期，那么 RFUZZ 需要生成 264(66*4) bit 的二进制序列。

![RFUZZ 输入定义](img/rfuzz-input-define.png)

RFUZZ 同样借鉴 AFL 设计了二进制突变原语，并且用 Rust 进行实现。二进制突变原语如下，可以看到和 AFL 大同小异：

![RFUZZ 突变原语](img/rfuzz-mutate-1.png)
![RFUZZ 突变原语](img/rfuzz-mutate-2.png)

对于处理器，RFUZZ 的测试对象是处理器内核加处理器数据段内存，其输入包括 32 位的指令信号、全局使能信号、全局复位信号、外部中断信号等，因此二进制的突变包括了对指令序列、全局控制信号、外部中断事件的生成，基本覆盖了处理器执行需要的执行内容。

**优点**：该二进制突变算法借鉴了 AFL 的成熟经验，在理论上可以覆盖所有可能的测试情况，实现起来也非常简洁。并且该算法是针对二进制级别进行突变的，具有很好的通用性，不仅适用于处理器硬件模糊测试，还适用于所有数字电路的硬件模糊测试。

<span id="rfuzz-mutate-shortcoming">**缺点**：</span>
二进制突变算法极强的通用性，也决定了它过于孱弱的专用性，即它没有针对处理器输入的特点进行突变。如我们在上一篇文章中提到的，信息量在二进制输入空间中分布是不均匀的，二进制突变算法给予每个输入一样的初始权重，是缺乏针对性的。RFUZZ 用二进制突变算法生成 32 位指令输入，一共有 $2^{32}$ 的突变范围，但是根据 RISCV 指令手册，只有很小一部分二进制组合是合法的指令，这导致大多数的突变生成都是非法指令，只能检测取值、译码等很有限的模块，而难以深入其他模块。此外，如 riscv-test 等手工的测试程序往往有几百条指令组成，且功能复杂，排列巧妙，希望 AFL 通过随机突变就生成如此复杂的指令组合，不啻于让猴子随机敲键盘写出莎士比亚的作品，因此其突变生成的指令序列规模及其有限。再加上其他的输入信息也需要满足一些条件约束才可以实现功能，这就导致输入能达到的功能进一步变差。虽然理论上，二进制突变算法只要有足够长的测试时间，就可以覆盖所有的执行情况；但实际上，时间是极其有限的，只有根据处理器的特点增加突变算法的针对性，才可以在有限的时间内覆盖更多的执行情况。

### FPGA 加速

过去的处理器验证工作主要是在 EDA 工具上仿真执行的，导致测试速度较慢。RFUZZ 设计了可综合的硬件验证框架，将验证平台迁移到 FPGA 上进行硬件加速，其对 Rocket 处理器的测试速度从 Verilator 的 6.89 KHz 提高到了 1.46 MHz，提高了 212 x。

FPGA 验证平台需要 FPGA 和上位机器相互配合，如下图所示：
1. Fuzzer 工具用二进制突变生成输入序列，然后写入 shared memory 的 input buffer
2. DMA 将 input buffer 中的信息发送给 FPGA 中的 StreamUnit，进而发送给 DUT
3. DMA 根据输入的测试样例进行执行，并且计算覆盖率，然后发送给 StreamUnit，通过 DMA 发送给 shared memory 的 Coverage Buffer
4. Fuzzer 从 Coverage Buffer 得到对应的覆盖率增长情况，然后调整突变策略，引导突变

因此 FPGA 除了将 coverage 插桩后的处理器 Verilog 综合下板子之外，还需要编写对应的 StreamUnit 和 Fuzzer 驱动代码。

![RFUZZ 的 FPGA 验证平台](img/rfuzz-veriy-platform.png)

**MetaReset 技术**：测试平台出于验证和复现的需要，需要处理器初始化到稳定可控的初始状态。但是很多寄存器在全局初始化结束之后就无法手动初始化，或者如部分中间寄存器根本不会被初始化（没有初始化状态），对此 RFUZZ 设计了 MetaReset 的 Chisel Transform。该 Transform 对处理器增加了全局的 MetaReset 信号，并且会在 Chisel 代码生成阶段对每个寄存器增加 MetaReset 高位有效的 0 初始化操作，从而解决初始化不可控或者无法初始化问题。如下面的代码，当 MetaRest=1 的时候，r 寄存器就可以初始化为 0。

```Verilog
    reg [31:0] r;            
    always@(posedge clk)begin
        if(reset)begin       
            r <= 32'h1993;   
        end else begin       
            r <= r_next;     
        end                  
    end                      
                            
    =>

    reg [31:0] r;               
    always@(posedge clk)begin   
        if(MetaReset)begin       // add MetaReset   
            r <= 32'h0;          // add MetaReset
        end else if(reset)begin
            r <= 32'h1993;
        end else begin
            r <= r_next;
        end
    end
``` 

**SparseMem 技术**：除了部分寄存器无法初始化之外，SRAM、DRAM 等内存也因为其物理特性无法初始化。考虑到 RFUZZ 模糊测试的内存访问规模很小，RFUZZ 用寄存器数组实现了可记录访存地址的稀疏数组结构，来取代原来的内存单元作为可复位的内存单元。
* 稀疏数组由一系列（地址、数据）对组成
* 当执行写操作的时候，根据地址更新对应的数据，或者分配新的表项写入
* 当执行读操作的时候，根据地址读出对应的数据，或者分配新的表项，返回初始值 0

SparseMem 读操作的电路图如下图所示：
![RFUZZ 的 SparseMem 读操作电路图](img/rfuzz-sparse-mem.png)

### 存在的问题

**缺少正确性检查模块**：RFUZZ 虽然搭建了完整的硬件模糊测试框架，但是没有设计的数字电路功能正确性检测模块，因此虽然该工作可以生成任意程序、覆盖各个数字电路功能点，但无法检测和报告电路内部存在的错误。（可以回顾上一篇文章，模糊测试仅负责触发程序内部各个状态，不负责检查状态的正确性和异常情况的发生，这是需要额外设计的）因此还需要设计功能检测模块，才可以自动化验证功能正确性。

**覆盖率指标缺乏整体性**：MUX SELECTOR 覆盖率指标仅仅考虑单个 MUX SELECTOR 的状态，不考虑整体的 MUX SELECTOR 组合情况，无法反映数字电路整体的执行情况。详情参见[覆盖率指标和覆盖率插桩](#rfuzz-cover-shortcoming)一节。

**二进制突变的局限性**：二进制突变难以在有限时间内生成足够多样性和复杂度的测试程序，并且对应的指令序列长度、规模、功能有限。详情参见[输入接口和二进制突变](#rfuzz-mutate-shortcoming)一节。

## hw-fuzzing

hw-fuzzing 是对标 RFUZZ 发表的工作，由 google 设计发表在 usenix 2022。不同于 RFUZZ 设计了新的硬件友好覆盖率指标和硬件加速的模糊测试技术，hw-fuzzing 认为硬件仿真程序本身就是一种特殊的软件，沿用成熟的传统软件模糊测试技术足以取得较好的成果。hw-fuzzing 充分利用已有的软件测试和验证技术，提高处理器验证能力；并设计了基于总线协议的数据输入格式，提高了数据生成的针对性和通用性。

![hw-fuzzing 论文题目](img/hw-fuzzing-title.png)

### hw-fuzzing 流水线

虽然硬件代码在设计方法和设计产物上和软件有巨大的区别，但是硬件在仿真模拟的时候，仍然会先被 EDA 工具转化为软件模型和二进制程执行。所以硬件在仿真模拟的时候，本质上还是一种特殊的软件，因此可以继续沿用软件模糊测试的技术进行硬件模糊测试。

hw-fuzzing 采用开源的仿真综合 Verilator 工具将数字电路 HDL、外围接口代码、仿真激励代码综合为硬件仿真二进制 HSB。仿真的软件引擎、覆盖率检测的软件引擎等可以软件库可以直接链接，得到完整的仿真程序。之外对于 HSB 的输入生成、突变、种子收集、漏洞检测、覆盖率反馈等和常规的软件模糊测试大同小异。
![硬件转化为软件](img/hw-fuzzing-2-soft.png)
![软件仿真平台](img/hw-fuzzing-platform.png)

* 在覆盖率检测方面，hw-fuzzing 并没有自定义新的覆盖率指标，而是沿用了 AFL 软件模糊测试自带的块代码覆盖率、边代码覆盖率的插桩机制
* 在输入生成和突变方面，hw-fuzzing 使用 AFL 对输入进行二进制突变，不过他对输入格式做了更进一步的定制，详情参见[总线中心的驱动设计](#hw-fuzzing-drive-design)
* 在漏洞检测方面，hw-fuzzing 一方面利用 SVA 进行违例检查，当内部状态不满足设计约束的时候程序崩溃；另一方面利用处理器模拟器作为黄金模型，用差分测试检测处理器执行结果的正确性。这有效解决了 RFUZZ 没有提供错误检测的问题。

虽然 hw-fuzzing 失去了 FPGA 综合加速的优点，降低了测试的速度；但是 hw-fuzzing 利用软件的灵活性，充分结合了已有的 AFL 模糊测试技术、SVA 检测技术、黄金模型模块，提供了通用、灵活、功能健全的测试框架。

### <span id="hw-fuzzing-drive-design">总线中心的驱动设计</span>

各个数字电路模块的接口格式和协议是互不相同的。RFUZZ 将接口输入简单的建模为二进制序列，虽然解决了通用性问题，但是因为约束过于宽泛，导致 AFL 生成有效输入的效率不高。hw-fuzzing 将待测的电路模块连接到 TILE-LINK Uncached Lightwreight(TL-UL) 总线上，这样多样化的接口协议就转化为了统一的 TL-UL 协议。

hw-fuzzing 设计了如下的 hw-fuzzing 模糊测试指令格式，格式为 8 bit 的 opcode，32 bit 的 address，32 bit 的 data。hw-fuzzing 的 testcase 生成程序生成一系列的 hw-fuzzing inst，然后交给 TL-UL 依次根据 opcode 执行：
* 如果 opcode 是 wait，TL-UL 等一个周期，不发送任何请求
* 如果 opcode 是 read，TL-UL 就执行读操作，读取待测模块对应地址的数据（如 output）
* 如果 opcode 是 write，TL-UL 久之行写操作，写入代测模块对应地址的数据（如 input）

![hw-fuzzing 驱动指令](img/hw-fuzzing-inst.png)
![hw-fuzzing 驱动指令工作](img/hw-fuzzing-inst-work.png)

该设计允许用户在总线和待测模块之间加入一层自定义的数据抽象，利用得当就可以解决待测模块数据交换时的协议问题（如握手信号满足约束），相对于 RFUZZ 有效解决了协议握手的问题。但是在 address/data 具体内容的生成上仍然缺乏针对性的约束，对处理器的针对性一般。这个设计启发我们，即使不在数据生成阶段对数据内容进行约束，在数据处理阶段对数据进行约束转换也是有意义的。

### 基于锁状态机状态探索的能力验证

为了验证 hw-fuzzing 对于复杂路径深入探索的能力，hw-fuzzing 设计了 lock FSM 的探索实验：

lock FSM 是一个简单的有限状态机，只有当输入依次是 $correct_1, correct_2 ... correct_n$ 的时候，lock FSM 的状态才可以从 $state_1, state_2$ 依次跳转到 $state_n$，然后输出 unlock，不然就保持不变。为了让 lock FSM 可以达到 unlock 状态，就需要模糊测试工具突变生成对应的输入序列。lock FSM 问题的 n 的值越大，模糊测试工具需要探索的路径越长，需要的能力也就越强。

![锁状态机探索实验](img/hw-fuzzing-lock-fsm.png)

该工作通过让 hw-fuzzing 求解不同难度的 lock FSM 问题来证明其探索能力，论文表明 hw-fuzzing 最多可以求解 480 个状态的 FSM。

### 缺点

除了设计了总线中心的驱动接口外，hw-fuzzing 更像是把已有的开源工具做了结合，提供了一个成熟易用的模糊测试验证平台，但对于生成约束和覆盖率设计这些核心问题，贡献乏善可陈。

## DifuzzRTL

DifuzzRTL 由 SNU 大学发表于 SP 2021，是处理器模糊测试的奠基之作。该工作针对处理器的特点，设计了基于指令的输入生成和突变技术，以及基于控制寄存器的全局覆盖率指标，为 RFUZZ 遗留的两大问题给出了基本解决思路；此外，DifuzzRTL 还囊括了中断生成机制和执行结果检查机制，实现的功能完整的测试验证框架，并支持硬件加速。这为后续的处理器模糊测试工作奠定了基本框架。

![DifuzzRTL 抬头](img/difuzzrtl-title.png)

### 基于控制寄存器的覆盖率指标

我们在介绍 RFUZZ 的时候指出，其 MUX SELECTOR 只能反映局部的执行情况，无法反映和覆盖全局的执行情况，DifuzzRTL 称之为：时间不敏感。直观的解决方法就是不使用单个 MUX SELECTOR 的值作为覆盖率指标，而是将所有的 MUX SELECTOR 组成一个高位向量，作为覆盖率指标，如 $(s_0, s_1, s_2 ... s_n)$。但是 MUX SELECTOR 的个数非常庞大，达到上万个，统计和存储这么大的覆盖率指标开销是巨大的，因此 DifuzzRTL 需要对该指标进行压缩。

考虑到 MUX SELECTOR 的值是由组合电路计算得到的，而组合电路的输入源于寄存器和外部输入。对于处理器这样的复杂电路，外部输入基本都会先用中间寄存器存储起来，因此可以简单认为组合电路的输入源于寄存器。DifuzzRTL 称参与 MUX SELECTOR 控制信号计算的源寄存器为控制寄存器，控制寄存器的值决定了控制信号的值，因此可以用控制寄存器值的组合近似等价于控制信号值的组合。一个控制寄存器往往决定多个控制信号的值，比如 Regfile 的 1 位写使能寄存器和 5 位索引寄存器可以控制所有 32 个寄存器写使能信号（指数级别的放大）。因此控制寄存器的值远少于控制信号，最大能起到指数级别的压缩效果。

DifuzzRTL 在 Chisel 代码生成的时候加入对应的 Transform，首先针对所有的 MUX SELECTOR 找到对应的源寄存器作为控制寄存器。DifuzzRTL 在每个周期将所有这些控制寄存器的值 hash 起来（进一步压缩），然后作为最终的 coverage 指标，置位对应的 cov_map，如果有新的 coverage，则累加 cov_sum。

![DifuzzRTL 的控制寄存器覆盖率统计](img/difuzzrtl-ctrl-cov.png)

### 基于指令格式的输入生成

DifuzzRTL 对处理器测试输入生成有了本质的飞跃。处理器作为特殊的数字电路，其工作流程是从内存中读入指令、解释指令、执行指令，指令是处理器执行的最小粒度，因此与其以 bit 为粒度进行输入生成，不如按照指令粒度进行输入生成。

考虑到合法指令本身的格式、各个位的值域是受到指令集手册严格约束的，因此 DifuzzRTL 根据指令集手册规定的指令格式生成满足 field 约束的合发指令。具体来说，DifuzzRTL 首先选择要生成指令的 opcode，然后根据 opcode 规定的指令格式进一步生成各个 field 的值。考虑到非法指令的存在，DifuzzRTL 也会刻意生成一些opcode 非法的指令，作为非法指令。和 RFUZZ 基于 bit 粒度的二进制突变技术相比，DifuzzRTL 基于指令格式的生成技术从根本上满足了指令内部约束，使得 DifuzzRTL 可以将更多的测试用在合法指令上。

后续指令突变的时候，就在原有指令的基础上突变其 operand、field 或者 opcode，确保指令格式仍然满足。

### 指令的摆放（控制流约束问题）

DifuzzRTL 虽然生成了一组合法的指令序列，但还需要将指令序列根据数据交换协议发送给处理器。RFUZZ 选择将指令直接发送给处理器内核暴露的 32 位指令接口，但 RFUZZ 仍然需要二进制突变生成有效的握手信号序列，才可以成功发送指令，这进一步降低了 RFUZZ 输入生成的有效性。DifuzzRTL 选择将指令直接存储到内存中，然后让处理器、内存通过总线协同工作，由总线接口电路直接完成数据交换协议——这个思路在 hw-fuzzing 中也有所体现。

处理器根据 PC 寄存器的值访问内存，读取对应的指令。如果指令在内存中只是简单地顺序摆放，当处理器执行了一条跳转操作之后，处理器就会不执行中间大量的指令，直接执行后续的指令，这会导致指令生成阶段生成的大量指令不会真的起到测试作用。如下图，第 2 条跳转指令直接跳转到第 101 条指令，导致中间 98 条指令没有被执行（实际经验指出，80% 以上的指令都会被略过）。因此，DifuzzRTL 需要将指令摆放到内存中合适的位置，构造控制流将所有指令尽可能多地串联起来，形成行之有效的程序。

```

    +-------------------+
    |       inst 1      |
    +-------------------+
    |       jmp 101     |--------+
    +-------------------+        |
    |         ...       |        |
    +-------------------+        |
    |       inst 100    |        |
    +-------------------+        |
    |       inst 101    |<-------+
    +-------------------+

```

DifuzzRTL 引入 spike 模拟器解决这一问题。第一条指令被摆放在处理器 PC 的初始位置，spike 模拟执行该指令，计算新的寄存器值和下一条 PC 值，然后将下一条指令摆放在该 PC 对应的内存位置，依次类推。最后 DifuzzRTL 得以确定所有的指令在内存中的位置，并且得到了所有寄存器最终的计算结果。（如果控制流出现 loop 怎么办？）这个指令排布会被生成一个 testcase，初始化到仿真的内存区域，或者通过 jtag 总线写入 FPGA 的内存单元。

这个控制流约束问题是后续所有基于内存的处理器模糊测试工作都必须解决的问题，它除了会导致大量指令不会被执行到外，还会进一步导致许多严重的问题。首先，处理器的执行代码包括：1.初始化代码，2.测试代码，3.结束代码。其中 1,3 部分是对测试没有帮助的系统开销，只有测试部分才有有意义的执行负载，测试代码可执行部分的降低，会导致有效执行时间大大降低。其次，突变程序并不知道测试代码的执行情况，简单地将覆盖率反馈当作所有的测试代码的贡献，于是很多没被执行到的优秀指令序列，会因为没有贡献新的覆盖率，而被突变技术抛弃，误导模糊测试的突变方向。

### 结果的检查（整体检测 vs 逐条检测）

我们最终介绍 DifuzzRTL 的结果检查方案。DifuzzRTL 的测试程序在执行结束之后，会跳转到一个特定代码块，该代码块会将所有的寄存器值写入到一个特殊的内存区域，从而暴露给测试者。软件仿真测试可以将改内存区域的值和 spike 模拟得到的最终结果进行比较，检验结果的正确性。硬件 FPGA 加速平台则可以将特殊内存区域的内容通过 StreamUnit 发送给上位机器，再加以比较。

相比于 hw-fuzzing 的逐条指令结果比较，DifuzzRTL 块定位的做法大大降低了比较的次数和数据量，特别是在硬件加速平台上，大大减少 FPGA 和上位机间传递的数据量——如果每执行一条指令就传递所有的寄存器值，则 FPGA 模拟就难以进行了。但另一方面，逐条比较的方法可以立即定位漏洞的位置，且错误不会被后续执行覆盖（如寄存器错误的值被后续计算覆盖），大大降低了错误定位的成本，也显著提高了漏洞检测的精度。

### 对中断触发、中断异常处理、虚拟地址的支持

**中断触发**：为了测试处理器处理外部中断的能力，输入生成的时候需要同时生成中断事件。DifuzzRTL 在生成每条指令的时候，会额外生成一个中断事件列表，包括是否发生中断、发生几个中断、各个中断的事件类型是什么（onehot 编码）。后序执行程序的时候，这些中断事件会被外部驱动依次触发，从而检验处理器的响应能力。

![中断事件序列生成](img/difuzzrtl-int.png)

**中断异常处理**：一方面，DifuzzRTL 会构造中断事件；另一方面，程序本身因为没有做更进一步的约束，潜在很多的异常（如 divide zero/access fault/illegal/ebreak 等）。当这些程序发生后，处理器要跳转到 mtvec/stvec 位置继续执行。对于 mtvec/stvec 的设置、后续代码的排布也可以作为随机生成的一部分，但是想要约束生成有意义的向量设置和处理程序是困难，且真实处理器中的向量设置和处理程序内容非常固定，没有太多随机测试的必要。因此 DifuzzRTL 放弃了对这部分功能的深入测试，而是照搬了 riscv-test/env 的异常处理程序代码简单处理。对于缺页异常，该代码分配并设置页表项，对于其他异常则 PC+4 返回，对于中断直接返回。详情参见第一篇文章对 riscv-test 的介绍。

**虚拟地址**：虚拟空间程序的正确运行依赖于正确的页表生成，但依靠二进制突变的方法直接生成正确的页表格式还是太困难了，这里 DifuzzRTL 照搬了 riscv-test 的页表设置方式。DifuzzRTL 首先不设置页表，然后等发生缺页异常的时候，异常处理程序再根据虚拟地址分配对应的物理地址、拷贝程序、设置页表，然后返回执行。参见第一篇文章对 riscv-test 的介绍。详情参见第一篇文章对 riscv-test 的介绍。

DifuzzRTL 对于页表和异常处理方式的选择也成为后续处理器模糊测试的默认范式。通过放弃对部分复杂但模式固定的硬件机制的测试，改用人为设计的固定代码直接支持。对于一个复杂的功能组件，在条件有限的情况下，也许我们没有必要把所有的功能都设计得面面俱到，选择最重要的功能重点设计，然后依次兼顾其他功能也是可取的。

最后我们对 DifuzzRTL 的流程进行小节：
* 根据种子库生成指令序列和中断事件列表
* 对指令序列、中断列表进行突变
* 通过模拟器模拟决定指令在内存中的位置，并生成最终执行结果
* 将指令存入内存，然后进行仿真/硬件执行
* 将执行结果和模拟器结果比较，汇报错误
* 根据覆盖率反馈调整突变策略和储存新的种子
* loop

![DifuzzRTL 工作流程](img/difuzzrtl-work-flow.png)

## ProcessorFuzz

ProcessorFuzz 发表在 HOST 2023 上，是对标 DifuzzRTL 做的改进工作。该工作在控制寄存器覆盖率指标的基础上设计了 CSR 寄存器覆盖率指标，并以此为基础设计了自洽的突变、结果检测、程序过滤技术，降低了执行时间和开销。但 ProcessorFuzz 总体来说并没有解决新的问题，也没有提供突破性的贡献。

![ProcessorFuzz 抬头](img/processorfuzz-title.png)

### CSR 寄存器覆盖率

DifuzzRTL 用控制寄存器值的摘要作为覆盖率指标，任何一个控制寄存器值的变化都会产生新的覆盖率，然后诱导突变。该策略认为所有的控制寄存器都是一样的重要的，乘法单元里的 FSM 寄存器的重要性和 CSR 中的 satp 寄存器的重要性是等价的，于是 DifuzzRTL 容易陷入对比较平庸的控制寄存器（如计算单元的 FSM 寄存器）引发的状态探索上，而放弃了对重要控制寄存器（如控制部件的寄存器）的状态探索。

ProcessorFuzz 指出，不同的控制寄存器重要性和地位是不一样的，诸如 satp、mstatus、mie 等寄存器可以直接影响整个处理器的工作状态，而诸如乘法单元、浮点单元内部的状态寄存器则只能影响局部电路的工作状态，显然前者的改变带来的状态改变更大，突变探索的价值更大。我们在上一篇文章中提到，覆盖率指标是对信息量的定量描述，覆盖率指标分布和信息量分布越吻合，起到的引导效果越好，同样是控制寄存器，前者就应该比后者分配到更大的权重，而不是简单的平均。

在所有的控制寄存器中，CSR 中起控制作用的架构层寄存器无疑是影响最广泛、应该分配的权重最高的，因此 ProcessorFuzz 干脆使用这部分 CSR 的状态变化作为覆盖率指标，而抛弃了其他次要的控制寄存器，相当于给 CSR 寄存器较高的权重，而给其他寄存器 0 权重。ProcessorFuzz 相当于在有限的测试时间内将探索收益最大化；而 DifuzzRTL 虽然在理论上有更大的未来收益，但实际上，因为测试时间有限，它即不能得到太高的既得收益，又没有时间给他在未来翻盘。

在判断控制寄存器权重的时候，有两个启发式的方法：
* 影响的 MUX 越多，权重越大
* 影响的电路功能相似或者相同，则权重降低；或者说影响电路功能越多，权重越大

并不是所有的 CSR 都是控制寄存器，诸如 mtvec、mepc、mscratch、mtval 等数据 buffer 并不能起到控制作用，因此被选作覆盖率指标的 CSR 寄存器仅下表的 20 个 CSR：

![作为覆盖率指标的 CSR 寄存器](img/processorfuzz-csr-table.png)

架构层的 CSR 只会因为 csr 指令和部分指令的副作用才会改变，根据 RISCV 指令集手册的定义，每条指令最多改变一个 CSR 的值，因此用所有寄存器的值的组合作为覆盖率指标，和用当前变化的寄存器的值的组合作为覆盖率指标效果是一样的。更进一步的，ProcessorFuzz 用当前指令引起的 CSR 值变化的三元组 (csr_name, before_value, after_value) 作为最终的覆盖率指标，csr_name 是寄存器的名字，before_value 是变化前的值，after_value 是变化后的值。该覆盖率指标反映了处理器状态的变化路径，在效果的改进上类似于 AFL 边覆盖率之于块覆盖率。

![csr 状态变化](img/processorfuzz-csr-pass.png)

### 逐条结果检测

DifuzzRTL 只在测试结束后进行一次结果检查，可能错过中间的错误结果，而 ProcessorFuzz 选择逐条检查就可以解决这个问题。但每次都检查所有的寄存器的值，会引入不小的开销。考虑到每条指令最多改变一个通用寄存器和若干个特权寄存器，因此只需要检查指令引入的寄存器差异即可，这就大大降低了需要检查的数据量。

ProcessorFuzz 在生成测试程序之后，让 ISA simulation 仿真执行，得到执行的 trace，然后检查相邻 trace 之间寄存器的变化情况，然后将这些寄存器变化记录下来作为每条指令执行结果的检查点。之后让 RTL simulation 执行测试程序，输出对应的 trace，然后进行 trace difference 的比较就可以了。

![代码执行流](img/processorfuzz-trace.png)

### 程序过滤

ProcessorFuzz 使用 CSR 的变化作为覆盖率，而 CSR 的变化在 ISA simulation 阶段就可以计算得到，因此在 RTL Simulation 之前，ProcessorFuzz 就可以知道覆盖率的增长情况。如果 ISA simulation 发现覆盖率没有提高，就可以略过 RTL simulation 阶段直接进行下一轮突变，节约了模糊测试的时间。

![ProcessorFuzz 流程图](img/processorfuzz-flow.png)

此外，因为不需要像 RFUZZ、DifuzzRTL 那样检查内部 MUX/REG 的状态，进而统计 coverage，ProcessorFuzz 不需要进行 RTL 插桩，又进一步节约了插桩的编译时间、降低了仿真时插桩电路的模拟时间。

### 和 DifuzzRTL 的比较结果

因为 ProcessorFuzz 只能软件模拟执行，无法进行硬件加速，所以这里是和 DifuzzRTL 的软件仿真部分比较的。可以看到 ProcessFuzz 的执行效率是 DifuzzRTL 的 2 倍，不过 ProcessFuzz 只有 1/3 的程序是真正执行的，其他 2/3 都是被过滤的。并用 1.23x 于 DifuzzRTL 的时间触发真实的处理器 bug。
![效率比较](img/processor-effective.png)

从覆盖率上看 ProcessorFuzz 反而略低于 DifuzzRTL。但是考虑到 ProcessorFuzz 只记录了 CSR 的状态变化，而 DifuzzRTL 则记录了所有控制寄存器状态变化，从这个角度看反而说明 ProcessorFuzz 效率、质量更高。
![覆盖率比较](img/processor-coverage.png)

不过还是要说明，这里的提高都比较有限，很难说产生了飞跃性的突破。

