# 处理器验证与处理器模糊测试（三）

之后，本文将介绍处理器模糊测试领域近年来有代表性 paper 的创新点和解决思路，帮助读者厘清学术界处理器模糊测试领域的发展脉络。

## RFUZZ

RFUZZ 发表于 ICCAD 2018，是近来学术界处理器模糊测试领域的滥觞之作。该论文将软件的模糊测试技术迁移到了硬件测试领域，针对硬件特性设计了对应的 MUX SELECTOR 覆盖率插桩，并移植 AFL 设计对应的二进制突变技术。此外，RFUZZ 构造 FPGA 模糊测试平台，对模糊测试进行硬件加速，适用于所有的数字电路。

![RFUZZ title](img/rfuzz_title.png)

### 覆盖率指标和覆盖率插桩

为了衡量模糊测试的质量，我们需要对硬件的覆盖率指标进行设计。在上一篇文章中我们介绍了传统的硬件覆盖率指标，如行覆盖率、分支覆盖率、状态机覆盖率等。这些覆盖率大多借鉴软件软件覆盖率的设计方法，与抽象的 Verilog 语句相关联，更适用于仿真测试的场景，这导致如下两个缺点：
* 对底层 RTL 单元的反映不够直接充分
* 覆盖率指标不可综合（难以综合），无法运用于硬件加速的测试场景

数字电路的电信号可以分为数据信号和控制信号两部分，控制信号指的就是各个 MUX 单元的 SELECTOR 信号，可以反映有限状态机的状态变化、数据的选择等信息，在设计思路上和传统覆盖率中的分支覆盖率有异曲同工之妙。因此 RFUZZ 使用数字电路中的各个 MUX 的 SELECTOR 的值作为覆盖率：
* 对于每个 1 位 MUX，SELECTOR = 0/1，共 2 个 coverage
* 对于每个 N 位 MUX，可以看作 $2^N - 1$ 个 MUX 的组合，共 $2^{N-1} - 2$ 个 coverage
* 每个 SELECTOR 的覆盖率相互独立，N 个 1 位 MUX，共 2N 个 coverage

RFUZZ 在 Chisel 编译阶段从 Verilog 层面对代码进行覆盖率插桩。RFUZZ 会对将每个 MUX 的 SELECTOR 接入一个 Coverage 记数单元，根据 SELECTOR 的值变化统计 CoverageSum，并且各个子部分的 CoverageSum 汇总到顶层得到总体的 CoverageSum。类似于如下的实现：

![RFUZZ MUX 覆盖率插桩](img/rfuzz-mux-cov.png)

**优点**：MUX SELECTOR 覆盖率和 RTL 单元紧密关联，直观反映了数字电路的执行状态，并且便于生成可综合的覆盖率插桩，从而可以结合 FPGA 进行覆盖率测量的硬件加速。

<span id="rfuzz-cover-shortcoming">**缺点**：</span>
MUX SELECTOR 用单个 SELECOTR 的值作为一个覆盖点，只反映了数字电路局部的覆盖情况，但是没有反映数字电路整体的覆盖情况。例如对于一个二位的 MUX SELECTOR，每个 SELECTOR 有 0/1 两种情况，当 MUX 遍历 01 和 10 两种情况后所有的覆盖点都被覆盖了，这样就将对 00 和 11 这两种覆盖点的探索排除在外。这是该覆盖率指标在设计之初就没能覆盖到的情况，需要设计覆盖范围更全面的指标来加以解决。

### 输入接口和二进制突变

为了进行模糊测试，我们需要设计测试样例生成和突变机制。RFUZZ 借鉴 AFL 设计了硬件的二进制生成和突变技术。

我们首先介绍 RFUZZ AFL 突变算法的输入定义：对于输入为 N 位的数字电路，我们需要检测该电路在 K 个时钟周期内的执行结果是否总是正确；因为数字电路每个周期有对应的 N 位输入，所以该数字电路需要接受 K 组 N 位输入，也就是长度为 KN 的二进制序列。如下图的 DUT 每周期接受 66(32+32+1+1) bit 的输入，共执行 4 个周期，那么 RFUZZ 需要生成 264(66*4) bit 的二进制序列。

![RFUZZ 输入定义](img/rfuzz-input-define.png)

RFUZZ 同样借鉴 AFL 设计了二进制突变原语，并且用 Rust 进行实现。二进制突变原语如下，可以看到和 AFL 大同小异：

![RFUZZ 突变原语](img/rfuzz-mutate-1.png)
![RFUZZ 突变原语](img/rfuzz-mutate-2.png)

对于处理器，RFUZZ 的测试对象是处理器内核加处理器数据段内存，其输入包括 32 位的指令信号、全局使能信号、全局复位信号、外部中断信号等，因此二进制的突变包括了对指令序列、全局控制信号、外部中断事件的生成，基本覆盖了处理器执行需要的执行内容。

**优点**：该二进制突变算法借鉴了 AFL 的成熟经验，在理论上可以覆盖所有可能的测试情况，实现起来也非常简洁。并且该算法是针对二进制级别进行突变的，具有很好的通用性，不仅适用于处理器硬件模糊测试，还适用于所有数字电路的硬件模糊测试。

<span id="rfuzz-mutate-shortcoming">**缺点**：</span>
二进制突变算法极强的通用性，也决定了它过于孱弱的专用性，即它没有针对处理器输入的特点进行突变。如我们在上一篇文章中提到的，信息量在二进制输入空间中分布是不均匀的，二进制突变算法给予每个输入一样的初始权重，是缺乏针对性的。RFUZZ 用二进制突变算法生成 32 位指令输入，一共有 $2^{32}$ 的突变范围，但是根据 RISCV 指令手册，只有很小一部分二进制组合是合法的指令，这导致大多数的突变生成都是非法指令，只能检测取值、译码等很有限的模块，而难以深入其他模块。此外，如 riscv-test 等手工的测试程序往往有几百条指令组成，且功能复杂，排列巧妙，希望 AFL 通过随机突变就生成如此复杂的指令组合，不啻于让猴子随机敲键盘写出莎士比亚的作品，因此其突变生成的指令序列规模及其有限。再加上其他的输入信息也需要满足一些条件约束才可以实现功能，这就导致输入能达到的功能进一步变差。虽然理论上，二进制突变算法只要有足够长的测试时间，就可以覆盖所有的执行情况；但实际上，时间是极其有限的，只有根据处理器的特点增加突变算法的针对性，才可以在有限的时间内覆盖更多的执行情况。

### FPGA 加速

过去的处理器验证工作主要是在 EDA 工具上仿真执行的，导致测试速度较慢。RFUZZ 设计了可综合的硬件验证框架，将验证平台迁移到 FPGA 上进行硬件加速，其对 Rocket 处理器的测试速度从 Verilator 的 6.89 KHz 提高到了 1.46 MHz，提高了 212 x。

FPGA 验证平台需要 FPGA 和上位机器相互配合，如下图所示：
1. Fuzzer 工具用二进制突变生成输入序列，然后写入 shared memory 的 input buffer
2. DMA 将 input buffer 中的信息发送给 FPGA 中的 StreamUnit，进而发送给 DUT
3. DMA 根据输入的测试样例进行执行，并且计算覆盖率，然后发送给 StreamUnit，通过 DMA 发送给 shared memory 的 Coverage Buffer
4. Fuzzer 从 Coverage Buffer 得到对应的覆盖率增长情况，然后调整突变策略，引导突变

因此 FPGA 除了将 coverage 插桩后的处理器 Verilog 综合下板子之外，还需要编写对应的 StreamUnit 和 Fuzzer 驱动代码。

![RFUZZ 的 FPGA 验证平台](img/rfuzz-veriy-platform.png)

**MetaReset 技术**：测试平台出于验证和复现的需要，需要处理器初始化到稳定可控的初始状态。但是很多寄存器在全局初始化结束之后就无法手动初始化，或者如部分中间寄存器根本不会被初始化（没有初始化状态），对此 RFUZZ 设计了 MetaReset 的 Chisel Transform。该 Transform 对处理器增加了全局的 MetaReset 信号，并且会在 Chisel 代码生成阶段对每个寄存器增加 MetaReset 高位有效的 0 初始化操作，从而解决初始化不可控或者无法初始化问题。如下面的代码，当 MetaRest=1 的时候，r 寄存器就可以初始化为 0。

```Verilog
    reg [31:0] r;            
    always@(posedge clk)begin
        if(reset)begin       
            r <= 32'h1993;   
        end else begin       
            r <= r_next;     
        end                  
    end                      
                            
    =>

    reg [31:0] r;               
    always@(posedge clk)begin   
        if(MetaReset)begin       // add MetaReset   
            r <= 32'h0;          // add MetaReset
        end else if(reset)begin
            r <= 32'h1993;
        end else begin
            r <= r_next;
        end
    end
``` 

**SparseMem 技术**：除了部分寄存器无法初始化之外，SRAM、DRAM 等内存也因为其物理特性无法初始化。考虑到 RFUZZ 模糊测试的内存访问规模很小，RFUZZ 用寄存器数组实现了可记录访存地址的稀疏数组结构，来取代原来的内存单元作为可复位的内存单元。
* 稀疏数组由一系列（地址、数据）对组成
* 当执行写操作的时候，根据地址更新对应的数据，或者分配新的表项写入
* 当执行读操作的时候，根据地址读出对应的数据，或者分配新的表项，返回初始值 0

SparseMem 读操作的电路图如下图所示：
![RFUZZ 的 SparseMem 读操作电路图](img/rfuzz-sparse-mem.png)

### 存在的问题

**缺少正确性检查模块**：RFUZZ 虽然搭建了完整的硬件模糊测试框架，但是没有设计的数字电路功能正确性检测模块，因此虽然该工作可以生成任意程序、覆盖各个数字电路功能点，但无法检测和报告电路内部存在的错误。（可以回顾上一篇文章，模糊测试仅负责触发程序内部各个状态，不负责检查状态的正确性和异常情况的发生，这是需要额外设计的）因此还需要设计功能检测模块，才可以自动化验证功能正确性。

**覆盖率指标缺乏整体性**：MUX SELECTOR 覆盖率指标仅仅考虑单个 MUX SELECTOR 的状态，不考虑整体的 MUX SELECTOR 组合情况，无法反映数字电路整体的执行情况。详情参见[覆盖率指标和覆盖率插桩](#rfuzz-cover-shortcoming)一节。

**二进制突变的局限性**：二进制突变难以在有限时间内生成足够多样性和复杂度的测试程序，并且对应的指令序列长度、规模、功能有限。详情参见[输入接口和二进制突变](#rfuzz-mutate-shortcoming)一节。

## hw-fuzzing

hw-fuzzing 是对标 RFUZZ 发表的工作，由 google 设计发表在 usenix 2022。不同于 RFUZZ 设计了新的硬件友好覆盖率指标和硬件加速的模糊测试技术，hw-fuzzing 认为硬件仿真程序本身就是一种特殊的软件，沿用成熟的传统软件模糊测试技术足以取得刚好的成果。hw-fuzzing 充分利用已有的软件测试和验证技术，提高处理器验证能力；并设计了基于总线协议的数据输入格式，提高了数据生成的针对性和通用性。

![hw-fuzzing 论文题目](img/hw-fuzzing-title.png)

### hw-fuzzing 流水线

虽然硬件代码在设计方法和设计产物上和软件有巨大的区别，但是硬件在仿真模拟的时候，仍然会先被 EDA 工具转化为软件模型和二进制程执行。所以硬件在仿真模拟的时候，本质上还是一种特殊的软件，因此可以继续沿用软件模糊测试的技术进行硬件模糊测试。

hw-fuzzing 采用开源的仿真综合 Verilator 工具将数字电路 HDL、外围接口代码、仿真激励代码综合为硬件仿真二进制 HSB。仿真的软件引擎、覆盖率检测的软件引擎等可以软件库可以直接链接，得到完整的仿真程序。之外对于 HSB 的输入生成、突变、种子收集、漏洞检测、覆盖率反馈等和常规的软件模糊测试大同小异。
![硬件转化为软件](img/hw-fuzzing-2-soft.png)
![软件仿真平台](img/hw-fuzzing-platform.png)

* 在覆盖率检测方面，hw-fuzzing 并没有自定义新的覆盖率指标，而是沿用了 AFL 软件模糊测试自带的块代码覆盖率、边代码覆盖率的插桩机制
* 在输入生成和突变方面，hw-fuzzing 使用 AFL 对输入进行二进制突变，不过他对输入格式做了更进一步的定制，详情参见[总线中心的驱动设计](#hw-fuzzing-drive-design)
* 在漏洞检测方面，hw-fuzzing 一方面利用 SVA 进行违例检查，当内部状态不满足设计约束的时候程序崩溃；另一方面利用处理器模拟器作为黄金模型，用差分测试检测处理器执行结果的正确性。这有效解决了 RFUZZ 没有提供错误检测的问题。

虽然 hw-fuzzing 失去了 FPGA 综合加速的优点，降低了测试的速度；但是 hw-fuzzing 利用软件的灵活性，充分结合了已有的 AFL 模糊测试技术、SVA 检测技术、黄金模型模块，提供了通用、灵活、功能健全的测试框架。

 ### <span id="hw-fuzzing-drive-design">总线中心的驱动设计</span>

各个数字电路模块的接口格式和协议是互不相同的。RFUZZ 将接口输入简单的建模为二进制序列，虽然解决了通用性问题，但是因为约束过于宽泛，导致 AFL 生成有效输入的效率不高。hw-fuzzing 将待测的电路模块连接到 TILE-LINK Uncached Lightwreight(TL-UL) 总线上，这样多样化的接口协议就转化为了统一的 TL-UL 协议。

hw-fuzzing 设计了如下的 hw-fuzzing 模糊测试指令格式，格式为 8 bit 的 opcode，32 bit 的 address，32 bit 的 data。hw-fuzzing 的 testcase 生成程序生成一系列的 hw-fuzzing inst，然后交给 TL-UL 依次根据 opcode 执行：
* 如果 opcode 是 wait，TL-UL 等一个周期，不发送任何请求
* 如果 opcode 是 read，TL-UL 就执行读操作，读取待测模块对应地址的数据（如 output）
* 如果 opcode 是 write，TL-UL 久之行写操作，写入代测模块对应地址的数据（如 input）

![hw-fuzzing 驱动指令](img/hw-fuzzing-inst.png)
![hw-fuzzing 驱动指令工作](img/hw-fuzzing-inst-work.png)

该设计允许用户在总线和待测模块之间加入一层自定义的数据抽象，利用得当就可以解决待测模块数据交换时的协议问题（如握手信号满足约束），相对于 RFUZZ 有效解决了协议握手的问题。但是在 address/data 具体内容的生成上仍然缺乏针对性的约束，对处理器的针对性一般。这个设计启发我们，即使不在数据生成阶段对数据内容进行约束，在数据处理阶段对数据进行约束转换也是有意义的。

### 基于锁状态机状态探索的能力验证

为了验证 hw-fuzzing 对于复杂路径深入探索的能力，hw-fuzzing 设计了 lock FSM 的探索实验：

lock FSM 是一个简单的有限状态机，只有当输入依次是 $correct_1, correct_2 ... correct_n$ 的时候，lock FSM 的状态才可以从 $state_1, state_2$ 依次跳转到 $state_n$，然后输出 unlock，不然就保持不变。为了让 lock FSM 可以达到 unlock 状态，就需要模糊测试工具突变生成对应的输入序列。lock FSM 问题的 n 的值越大，模糊测试工具需要探索的路径越长，需要的能力也就越强。

![锁状态机探索实验](img/hw-fuzzing-lock-fsm.png)

该工作通过让 hw-fuzzing 求解不同难度的 lock FSM 问题来证明其探索能力，论文表明 hw-fuzzing 最多可以求解 480 个状态的 FSM。

### 缺点

除了设计了总线中心的驱动接口外，hw-fuzzing 更像是把已有的开源工具做了结合，提供了一个成熟易用的模糊测试验证平台，但对于生成约束和覆盖率设计这些核心问题，贡献乏善可陈。

