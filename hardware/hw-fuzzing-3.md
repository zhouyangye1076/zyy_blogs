# 处理器验证与处理器模糊测试（三）

之后，本文将介绍处理器模糊测试领域近年来有代表性 paper 的创新点和解决思路，帮助读者厘清学术界处理器模糊测试领域的发展脉络。

## RFUZZ

RFUZZ 发表于 ICCAD 2018，是近来学术界处理器模糊测试领域的滥觞之作。该论文将软件的模糊测试技术迁移到了硬件测试领域，针对硬件特性设计了对应的 MUX SELECTOR 覆盖率插桩，并移植 AFL 设计对应的二进制突变技术。此外，RFUZZ 构造 FPGA 模糊测试平台，对模糊测试进行硬件加速，适用于所有的数字电路。

![RFUZZ title](img/rfuzz_title.png)

### 覆盖率指标和覆盖率插桩

为了衡量模糊测试的质量，我们需要对硬件的覆盖率指标进行设计。在上一篇文章中我们介绍了传统的硬件覆盖率指标，如行覆盖率、分支覆盖率、状态机覆盖率等。这些覆盖率大多借鉴软件软件覆盖率的设计方法，与抽象的 Verilog 语句相关联，更适用于仿真测试的场景，这导致如下两个缺点：
* 对底层 RTL 单元的反映不够直接充分
* 覆盖率指标不可综合（难以综合），无法运用于硬件加速的测试场景

数字电路的电信号可以分为数据信号和控制信号两部分，控制信号指的就是各个 MUX 单元的 SELECTOR 信号，可以反映有限状态机的状态变化、数据的选择等信息，在设计思路上和传统覆盖率中的分支覆盖率有异曲同工之妙。因此 RFUZZ 使用数字电路中的各个 MUX 的 SELECTOR 的值作为覆盖率：
* 对于每个 1 位 MUX，SELECTOR = 0/1，共 2 个 coverage
* 对于每个 N 位 MUX，可以看作 $2^N - 1$ 个 MUX 的组合，共 $2^{N-1} - 2$ 个 coverage
* 每个 SELECTOR 的覆盖率相互独立，N 个 1 位 MUX，共 2N 个 coverage

RFUZZ 在 Chisel 编译阶段从 Verilog 层面对代码进行覆盖率插桩。RFUZZ 会对将每个 MUX 的 SELECTOR 接入一个 Coverage 记数单元，根据 SELECTOR 的值变化统计 CoverageSum，并且各个子部分的 CoverageSum 汇总到顶层得到总体的 CoverageSum。类似于如下的实现：

![RFUZZ MUX 覆盖率插桩](img/rfuzz-mux-cov.png)

**优点**：MUX SELECTOR 覆盖率和 RTL 单元紧密关联，直观反映了数字电路的执行状态，并且便于生成可综合的覆盖率插桩，从而可以结合 FPGA 进行覆盖率测量的硬件加速。

<span id="rfuzz-cover-shortcoming">**缺点**：</span>
MUX SELECTOR 用单个 SELECOTR 的值作为一个覆盖点，只反映了数字电路局部的覆盖情况，但是没有反映数字电路整体的覆盖情况。例如对于一个二位的 MUX SELECTOR，每个 SELECTOR 有 0/1 两种情况，当 MUX 遍历 01 和 10 两种情况后所有的覆盖点都被覆盖了，这样就将对 00 和 11 这两种覆盖点的探索排除在外。这是该覆盖率指标在设计之初就没能覆盖到的情况，需要设计覆盖范围更全面的指标来加以解决。

### 输入接口和二进制突变

为了进行模糊测试，我们需要设计测试样例生成和突变机制。RFUZZ 借鉴 AFL 设计了硬件的二进制生成和突变技术。

我们首先介绍 RFUZZ AFL 突变算法的输入定义：对于输入为 N 位的数字电路，我们需要检测该电路在 K 个时钟周期内的执行结果是否总是正确；因为数字电路每个周期有对应的 N 位输入，所以该数字电路需要接受 K 组 N 位输入，也就是长度为 KN 的二进制序列。如下图的 DUT 每周期接受 66(32+32+1+1) bit 的输入，共执行 4 个周期，那么 RFUZZ 需要生成 264(66*4) bit 的二进制序列。

![RFUZZ 输入定义](img/rfuzz-input-define.png)

RFUZZ 同样借鉴 AFL 设计了二进制突变原语，并且用 Rust 进行实现。二进制突变原语如下，可以看到和 AFL 大同小异：

![RFUZZ 突变原语](img/rfuzz-mutate-1.png)
![RFUZZ 突变原语](img/rfuzz-mutate-2.png)

对于处理器，RFUZZ 的测试对象是处理器内核加处理器数据段内存，其输入包括 32 位的指令信号、全局使能信号、全局复位信号、外部中断信号等，因此二进制的突变包括了对指令序列、全局控制信号、外部中断事件的生成，基本覆盖了处理器执行需要的执行内容。

**优点**：该二进制突变算法借鉴了 AFL 的成熟经验，在理论上可以覆盖所有可能的测试情况，实现起来也非常简洁。并且该算法是针对二进制级别进行突变的，具有很好的通用性，不仅适用于处理器硬件模糊测试，还适用于所有数字电路的硬件模糊测试。

<span id="rfuzz-mutate-shortcoming">**缺点**：</span>
二进制突变算法极强的通用性，也决定了它过于孱弱的专用性，即它没有针对处理器输入的特点进行突变。如我们在上一篇文章中提到的，信息量在二进制输入空间中分布是不均匀的，二进制突变算法给予每个输入一样的初始权重，是缺乏针对性的。RFUZZ 用二进制突变算法生成 32 位指令输入，一共有 $2^{32}$ 的突变范围，但是根据 RISCV 指令手册，只有很小一部分二进制组合是合法的指令，这导致大多数的突变生成都是非法指令，只能检测取值、译码等很有限的模块，而难以深入其他模块。此外，如 riscv-test 等手工的测试程序往往有几百条指令组成，且功能复杂，排列巧妙，希望 AFL 通过随机突变就生成如此复杂的指令组合，不啻于让猴子随机敲键盘写出莎士比亚的作品，因此其突变生成的指令序列规模及其有限。虽然理论上，二进制突变算法只要有足够长的测试时间，就可以覆盖所有的执行情况；但实际上，时间是极其有限的，只有根据处理器的特点增加突变算法的针对性，才可以在有限的时间内覆盖更多的执行情况。

### FPGA 加速

过去的处理器验证工作主要是在 EDA 工具上仿真执行的，导致测试速度较慢。RFUZZ 设计了可综合的硬件验证框架，将验证平台迁移到 FPGA 上进行硬件加速，其对 Rocket 处理器的测试速度从 Verilator 的 6.89 KHz 提高到了 1.46 MHz，提高了 212 x。

FPGA 验证平台需要 FPGA 和上位机器相互配合，如下图所示：
1. Fuzzer 工具用二进制突变生成输入序列，然后写入 shared memory 的 input buffer
2. DMA 将 input buffer 中的信息发送给 FPGA 中的 StreamUnit，进而发送给 DUT
3. DMA 根据输入的测试样例进行执行，并且计算覆盖率，然后发送给 StreamUnit，通过 DMA 发送给 shared memory 的 Coverage Buffer
4. Fuzzer 从 Coverage Buffer 得到对应的覆盖率增长情况，然后调整突变策略，引导突变

因此 FPGA 除了将 coverage 插桩后的处理器 Verilog 综合下板子之外，还需要编写对应的 StreamUnit 和 Fuzzer 驱动代码。

![RFUZZ 的 FPGA 验证平台](img/rfuzz-veriy-platform.png)

**MetaReset 技术**：测试平台出于验证和复现的需要，需要处理器初始化到稳定可控的初始状态。但是很多寄存器在全局初始化结束之后就无法手动初始化，或者如部分中间寄存器根本不会被初始化（没有初始化状态），对此 RFUZZ 设计了 MetaReset 的 Chisel Transform。该 Transform 对处理器增加了全局的 MetaReset 信号，并且会在 Chisel 代码生成阶段对每个寄存器增加 MetaReset 高位有效的 0 初始化操作，从而解决初始化不可控或者无法初始化问题。如下面的代码，当 MetaRest=1 的时候，r 寄存器就可以初始化为 0。

```Verilog
reg [31:0] r;            |reg [31:0] r;               
always@(posedge clk)begin|always@(posedge clk)begin   
    if(reset)begin       |    if(MetaReset)begin          
        r <= 32'h1993;   |       r <= 32'h0;      
    end else begin       |   end else if(reset)begin
        r <= r_next;     |       r <= 32'h1993;
    end                  |   end else begin
end                      |       r <= r_next;
                         |   end
                         |end
``` 

**SparseMem 技术**：除了部分寄存器无法初始化之外，SRAM、DRAM 等内存也因为其物理特性无法初始化。考虑到 RFUZZ 模糊测试的内存访问规模很小，RFUZZ 用寄存器数组实现了可记录访存地址的稀疏数组结构，来取代原来的内存单元作为可复位的内存单元。
* 稀疏数组由一系列（地址、数据）对组成
* 当执行写操作的时候，根据地址更新对应的数据，或者分配新的表项写入
* 当执行读操作的时候，根据地址读出对应的数据，或者分配新的表项，返回初始值 0

SparseMem 读操作的电路图如下图所示：
![RFUZZ 的 SparseMem 读操作电路图](img/rfuzz-sparse-mem.png)

### 存在的问题

**缺少正确性检查模块**：RFUZZ 虽然搭建了完整的硬件模糊测试框架，但是没有设计的数字电路功能正确性检测模块，因此虽然该工作可以生成任意程序、覆盖各个数字电路功能点，但无法检测和报告电路内部存在的错误。（可以回顾上一篇文章，模糊测试仅负责触发程序内部各个状态，不负责检查状态的正确性和异常情况的发生，这是需要额外设计的）因此还需要设计功能检测模块，才可以自动化验证功能正确性。

**覆盖率指标缺乏整体性**：MUX SELECTOR 覆盖率指标仅仅考虑单个 MUX SELECTOR 的状态，不考虑整体的 MUX SELECTOR 组合情况，无法反映数字电路整体的执行情况。详情参见[覆盖率指标和覆盖率插桩](#rfuzz-cover-shortcoming)一节。

**二进制突变的局限性**：二进制突变难以在有限时间内生成足够多样性和复杂度的测试程序，并且对应的指令序列长度、规模、功能有限。详情参见[输入接口和二进制突变](#rfuzz-mutate-shortcoming)一节。

