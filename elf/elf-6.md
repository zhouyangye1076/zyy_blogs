# ELF 的一些探索（六）：堆栈段和函数调用

## .stack 堆栈段

函数的调用过程是一个先进后出的过程，比如说 main 函数调用了 func1，func1 调用了 func2，func2 调用 func3。之后 func3 先开始执行，执行完毕后退出执行 func2，func2 执行完后退出执行 func1，func1 最后返回 main。一个函数在执行的时候也是要维护自己的数据的，包括局部变量、返回地址、栈帧等信息，所以我们可以事先实现一个全局的堆栈来维护这些数据结构。当执行一个函数的时候就将他的这些数据结构 push 到一个 stack 中，当退出这个函数的时候就将这些数据结构从 stack 中 pop 出去。这个堆栈可以用一个可读可写的数据段来实现。

我们可以在汇编程序中这样使用堆栈段：这里建立了一个大小为 0x1000 字节的 .stack 作为堆栈，stack_bottom label 指示了堆栈的栈底，然后使用这个堆栈作为程序的堆栈。我们先不考虑设计内核和 glibc 的真实的 C 程序的加载和运行，仅考虑一个物理地址裸机的 C 程序的执行。这个时候我们首先从 _start 入口开始执行程序，然后将 sp 寄存器设置为 stack_bottom 指向堆栈段的栈底，在之后的程序中我们将使用 sp 寄存器管理堆栈段。然后我们跳入 main 函数开始执行程序。 

```
ENTRY(_start)

.section .text
_start:
    la sp, stack_bottom
    j main
main:
    ....

.section .stack
stack_top:
    .space 0x1000
stack_bottom:

```

## 函数

现在我们来看一下 C 程序是如何进行函数调用和堆栈管理的。

我们来对比以下两个函数和它们对应的汇编，C 函数如下：

```C
    int add(int a, int b){
        int sum = a + b;
        return sum;
    }

    int mul_add(int a, int b, int c){
        int sum = a * b;
        sum = add(sum, c);
        return sum;
    }
```

然后我们将他们编译为 riscv 的汇编，然后用`riscv64-linux-gnu-objdump -d -S`反汇编得到 C 语句和对应的汇编语句交错的格式，方便我们查看每个 C 语句对应的汇编语句。可以看到 mul_add 函数当中的函数调用语句`sum = add(sum, c);`的反汇编如下图所示。

```
    sum = add(sum, c);
 688:	fd442703          	lw	a4,-44(s0)      //  a4 <- c
 68c:	fec42783          	lw	a5,-20(s0)      //  a5 <- sum
 690:	85ba                	mv	a1,a4       //  a1 <- a4 <- c
 692:	853e                	mv	a0,a5       //  a0 <- a5 <- sum
 694:	f95ff0ef          	jal	ra,628 <add>    //  call func add with param a0, a1
 698:	87aa                	mv	a5,a0       //  the return value of func add is in a0
 69a:	fef42623          	sw	a5,-20(s0)      //  sum <- a0
```

### 函数调用
在 C 语言的视角里，函数调用需要完成三个任务：
* 将参数传递给被调用的函数
* 执行被调用的函数
* 将被调用的函数的返回值返传递给调用方
我们来从会变的视角看看这三个问题是如何被解决的。

这里我们先不妨预先告诉大家，-44(s0) 和 -20(s0) 分别是变量 c 和 sum 的地址。所以首先执行 `lw	a4,-44(s0)` 和 `lw	a5,-20(s0)` 将 c 和 sum 的值从内存读入寄存器，然后执行 `mv	a1,a4` 和 `mv	a0,a5` 将 a4、a5 的值写入寄存器 a1、a0，或者说将 c 和 sum 的值写入寄存器 a0、a1。到这一步位置，我们将调用函数需要的参数的值保存到了 a0、a1 这两个寄存器中。然后执行 `jal ra，add`，这一步将 698 的地址保存到了 ra 寄存器，然后将控制流跳转到了 add 函数，于是 CPU 开始执行 add 之后的指令也就是执行 add 函数的代码。所以可以想象对面的 add 函数必然是通过 a0、a1 这两个寄存器获得需要的参数 sum 和 c 的值，故而 688-692 的指令实现了函数传参的任务，而 694 完成了函数调用的任务。

我们都知道函数调用完毕之后，会返回调用函数的语句的下一句开始继续执行，所以 add 函数执行结束后需要返回到地址 698 继续执行，但是这个地址 698 只在执行`jal ra，add`的时候被保存到了 ra 寄存器中，所以 add 函数必然是依靠 ra 寄存器存储的值返回调用函数继续执行的，也即 ra 保存了 add 函数的返回地址。ra 是 return address 的缩写，这个函数就是被用于存储函数返回地址的。

add 函数返回之后从 698 开始继续执行程序，也就是开始执行指令 `mv	a5,a0` 和 `sw	a5,-20(s0)`，前者将 a0 寄存器的值交给 a5 寄存器，后者将 a5 寄存器的值写入内存 -20(s0) 也就是内存 sum，所以这一步是在将 `add(sum, c)` 的值写入 sum 变量。所以 a0 的值就是 `add(sum, c)` 的计算结果，也就是 add 函数的返回值，所以可以想见 add 函数在返回原函数之前，会首先将返回值保存在 a0 寄存器中。

现在我们对这部分会变得功能做一个简单的总结：

* 将被调用函数的参数保存到寄存器 a0、a1 中
* 用 `jal ra, func` 指令跳转到被调用函数 func 的开头，在完成函数调用的同时，将函数的返回地址保存到寄存器 ra 中
* func 函数根据 a0、a1 获得参数，开始函数执行
* func 执行完毕后将返回值保存到寄存器 a0，然后根据 ra 返回原函数继续执行
* 原函数通过 a0 获得返回值，开始后续计算

实际上 riscv 中的一组寄存器 a0-a7 就是专门用于函数传参的，函数 func 的参数 param0 - paramN 依次通过寄存器 a0 - aN 传递。不过如果一个函数的参数超过 8 个怎么办？这个问题我们在之后的进阶部分再做进一步的回答。

### 函数执行

现在我们通过 add 函数的汇编来看看函数执行的过程和对应的指令细节。对应的汇编如下：
```
int add(int a, int b){
 628:	7179                	addi	sp,sp,-48
 62a:	f422                	sd	s0,40(sp)
 62c:	1800                	addi	s0,sp,48
 62e:	87aa                	mv	a5,a0
 630:	872e                	mv	a4,a1
 632:	fcf42e23          	sw	a5,-36(s0)
 636:	87ba                	mv	a5,a4
 638:	fcf42c23          	sw	a5,-40(s0)
    int sum = a + b;
 63c:	fdc42783          	lw	a5,-36(s0)
 640:	873e                	mv	a4,a5
 642:	fd842783          	lw	a5,-40(s0)
 646:	9fb9                	addw	a5,a5,a4
 648:	fef42623          	sw	a5,-20(s0)
    return sum;
 64c:	fec42783          	lw	a5,-20(s0)
}
 650:	853e                	mv	a0,a5
 652:	7422                	ld	s0,40(sp)
 654:	6145                	addi	sp,sp,48
 656:	8082                	ret
```

mul_add 调用 add 函数，控制流进入 add label 所在的地址之后，首先执行的第一段代码如下。这段代码并不是 add 函数第一条语句对应的代码，而是 add 函数为了维护函数的结构需要执行的第一段代码。我们之前说过函数的调用和堆栈是有异曲同工之妙的，函数先入后出的调用方式和局部空间的管理方式就如同堆栈一样。所以我们使用堆栈段来维护函数的局部空间，因此函数的开头需要有一段代码将函数的局部空间保存到堆栈段中，等函数退出的时候将这个局部空间从堆栈段中删除。
```
int add(int a, int b){
 628:	7179                	addi	sp,sp,-48
 62a:	f422                	sd	s0,40(sp)
 62c:	1800                	addi	s0,sp,48
 62e:	87aa                	mv	a5,a0
 630:	872e                	mv	a4,a1
 632:	fcf42e23          	sw	a5,-36(s0)
 636:	87ba                	mv	a5,a4
 638:	fcf42c23          	sw	a5,-40(s0)
```

#### 开辟栈帧
首先执行的`addi	sp,sp,-48`，然后 sp 指针在堆栈段的位置向上移动了 48 个字节，相当于在堆栈段中新开辟了 48 字节的空间，则会部分空间就是用于作为函数 add 的局部空间使用的（也就是将局部空间 push 到堆栈里面）。然后我们执行`sd	s0,40(sp)`指令，将 s0 寄存器的值保存到这 48 自己的末尾 8 字节。最后我们执行`addi	s0,sp,48`，于是 s0 的值就等于原来的 sp 的值。

通过这三条指令，我们为函数 add 在堆栈段中开辟了 48 字节的堆栈空间，其中 sp 指针指向这个空间的起始地址，而 s0 寄存器指向这个局部空间的结束地址。对于函数而言这部分堆栈空间叫做栈帧 stack frame，用于存储函数执行期间需要的所有数据信息。sp 寄存器全称叫做 stack pointer，用于堆栈的管理和指示栈帧的栈顶。s0 寄存器又叫做 fp 寄存器，全称是 frame pointer，用于指向栈桢的结束地址。

#### 保存寄存器
我们可以想象每个函数都有自己的栈帧，都有自己的 sp、fp 寄存器的值。每当一个函数调用另一个函数之后，新函数就会构造自己的栈帧和赋值自己的 sp、fp 函数，这就会导致原来的函数的 sp、fp 寄存器的值被覆盖，为了在函数返回之后可以恢复寄存器 fp 的值，所以这里将 fp 寄存器原来的值保存到栈帧当中。其实不仅仅 fp 寄存器需要在函数开头被保存到堆栈栈帧当中，任何还需要被使用的寄存器值都需要保存到寄存器中，主要是两种。

第一种是返回地址寄存器 ra。ra 寄存器被用于保存函数的返回地址，所以每个函数都需要 ra 保存自己的返回地址。但是当一个函数调用另一个函数时，被调用的函数的返回地址就会覆盖 ra 中调用函数的返回地址，导致该函数失去返回地址。为了防止这种情况出现，如果一个函数需要调用其他函数，则该函数的 ra 寄存器的值也会在函数一开始被保存到栈帧的某一位置。

第二种是变量寄存器 s0 - sN。在 mul_add 函数中我们可以看到，sum 和 c 变量是保存在内存中的，所以每次需要对 sum 和 c 做操作就要用 ld 指令和 sd 指令将值在内存和寄存器之间来回传递，这无疑降低了函数执行的效率。考虑到一些变量会被反复使用，反复从内存读入寄存器，再反复从寄存器写入内存，所以可以考虑将某些寄存器直接分配给一些变量使用。riscv 处理器的寄存器 x8、x9、x18-x27 又被称为 s0-s11，也就是 saved reg 的意思，它们可以被专门用作存储变量的寄存器，例如 mul_add 就可以考虑将 s0、s1 作为 sum 和 c 变量对于的存储单元，这样当我们需要读、写计算这些变量的时候就可以直接用寄存器参与计算，而不需要做内存交互。如果一个函数需要使用 s0-s11 作为寄存器变量，那么它需要充分考虑调用它的函数也可能使用 s0-s11 作为寄存器变量，那么他的操作就会覆盖调用它的函数的寄存器的值，进而导致推出到原函数后，该函数无法顺利执行。因此该函数在使用 s0-s11 寄存器之前有义务将他们保存到堆栈空间，以确保调用方执行正确。

#### 保存参数
add 函数传入了参数 a 和 b，在 C 的模型中传入的参数会分配内存成为局部变量，所以汇编也会在堆栈中分配一段空间作为这些参数变量对应的存储。我们可以看到 a0、a1 分别存入寄存器 a5、a4，然后存入 -36(s0)、-40(s0)。这个内存范围就是栈帧的内存范围，虽然栈帧是用 sp、fp 共同决定其范围的，但是当需要对栈帧里存储的寄存器、返回地址、局部变量等等进行访问的时候，还是习惯于用 fp 指针作为基地址进行访问，而不是 sp。
```
 62e:	87aa                	mv	a5,a0
 630:	872e                	mv	a4,a1
 632:	fcf42e23          	sw	a5,-36(s0)
 636:	87ba                	mv	a5,a4
 638:	fcf42c23          	sw	a5,-40(s0)
```

#### 局部变量管理
对于`sum = a + b`的操作就是访问变量 a、b 的内存得到对应的数据，做加法之后保存到变量 sum 对应的内存中。我们可以看到 sum、a、b 作为 add 函数的局部变量它们的地址都在栈帧当中，分别是 -20(s0)、-36(s0)、-40(s0)。反言之，如果函数需要一个局部变量，那么在开辟栈桢的时候就会为这些局部变量预留空间，然后为每个变量分配对应的 offset，然后后续如果想访问这个变量就可以用 fp 加上对应的 offset 来进行访问。比如 sum 分配的范围就是 -20~-16，a 是 -36~-32，b 是 -40~-36。
```
    int sum = a + b;
 63c:	fdc42783          	lw	a5,-36(s0)
 640:	873e                	mv	a4,a5
 642:	fd842783          	lw	a5,-40(s0)
 646:	9fb9                	addw	a5,a5,a4
 648:	fef42623          	sw	a5,-20(s0)
```

#### 函数退出
函数进入需要开辟空间、保存寄存器，函数退出就需要恢复堆栈空间、恢复寄存器。我们来看一下细节。
```
    return sum;
 64c:	fec42783          	lw	a5,-20(s0)
}
 650:	853e                	mv	a0,a5
 652:	7422                	ld	s0,40(sp)
 654:	6145                	addi	sp,sp,48
 656:	8082                	ret
```
首先执行`lw	a5,-20(s0)`和`mv	a0,a5`，将变量 sum 的值存入寄存器 a0。因为函数调用约定中规定函数的返回值保存在寄存器 a0 中，所以被调用的函数在退出前需要让寄存器 a0 的值等于返回值。然后执行`ld	s0,40(sp)`，恢复寄存器 fp，如果有其他的寄存器比如 ra、s1-s11需要恢复，也在这里进行恢复。然后执行`addi	sp,sp,48`将 sp 恢复原值，也就是上一个函数的栈帧顶，因为函数知道自己的栈帧大小，所以它可以直接减去栈帧大小，恢复 sp 的原值；但是函数不知道调用它的函数的栈帧大小，所以没有办法通过减立即数的方法让 fp 恢复，只能用保存到栈帧的方法恢复。最后执行`ret`也就是`jalr zero, 0(ra)`，返回到调用函数的返回地址继续执行。

一个函数可能有多个 return 出口，但是在汇编中，他其实只有函数末尾一个出口。各个 return 语句一般是将返回值写入 a0 寄存器，然后跳转到函数结尾，然后统一执行恢复寄存器、撤销栈帧等操作。

现在我们可以总结一下函数调用的大致流程：
* 为保留寄存器、局部变量开辟栈桢
* 存储 fp、将 fp 设置为栈帧底
* 存储返回地址、s0-s11 等寄存器
* 将传入的参数存入对应的局部变量
* 执行各种操作，包括局部变量的读写和函数调用
* 将返回值写入 a0 寄存器
* 恢复 fp、ra、s0-s11 等保留寄存器
* 撤销栈帧，恢复 sp 寄存器
* 根据 ra 返回原函数

### 函数调用约定

riscv 有 32 个用于整数运算的通用寄存器，我们称之为 general purpose register，简称 GPR。在硬件实现上这个 32 个寄存器除了第一个寄存器 x0 以外都是完全对称的，所以纯理论而言，这 31 个寄存器的使用没有任何区别。但是在 C 程序当中我们需要有寄存器存储返回地址，有寄存器管理堆栈，有寄存器传递参数等等，为了防止不同的编程者使用不同的寄存器，导致函数的调用者和被调用者传参不一致，所以预先为每个寄存器预设了功能和调用协议。大家都按照这个协议进行函数编写，这样即使调用者和被调用者不进行任何约定，双方都可以配合成功。

| register | abi name | description        | saver |
|----------|----------|--------------------|-------|
|x0        | zero     | hard-wired zero    |       |
|x1        | ra       | return address     |caller |
|x2        | sp       | stack pointer      |callee |
|x3        | gp       | global pointer     |       |
|x4        | tp       | thread pointer     |       |
|x5-7,28-31| t0-6     | temporary          |caller |
|x8        | s0/fp    | frame pointer      |callee |
|x9,18-27  | s1-11    | saved register     |callee |
|x10-17    | a0-7     | function arguments |caller |

* zero 寄存器是被硬编码为数值 0 的，无论怎样写入，它读到的结果都是 0
* ra 寄存器被用于存储处理器的返回地址，由调用方负责保存
* sp 寄存器被用于管理堆栈的栈顶，由被调用方负责保存
* gp 寄存器被用于全局数据的访问，除了被用于寻址全局变量不做其他用途，不涉及函数调用
* tp 寄存器被用于线程私有变量的保护
* fp 寄存器被用于管理栈帧，由被调用方负责保存
* s0-11 寄存器被用于存储变量，由被调用方负责保存
* a0-7 寄存器被用于函数传参和返回值传递，由被调用方负责保存
* t0-7 寄存器被用于临时计算使用，它的值应该被快速使用和抛弃，由调用方负责保存

### 递归函数

递归函数其实没有什么特别的，不过是函数自己调用自己而已，每次自己调用自己就传入参数，然后转移控制流、开辟堆栈也就是了。

函数调用的深度很多时候是比较有限的，如果只是仅仅操作流程导致的函数调用，几十个就已经很多了。所以最多在堆栈产生深度为几十的调用栈，然后依次堆叠几十个栈帧。不过堆栈的递归调用很多时候，是随着数据规模的增长而增长的，比如归并排序的递归调用深度就是 logN，向 fib 可以达到 N。如果要处理的数据规模过分大，会导致递归调用深度过深，堆栈空间使用过多。在我们这个例子中是使用一个 0x1000 的内存作为堆栈的，所以当所有的堆栈空间加起来超过 0x1000 时就会导致堆栈溢出。堆栈溢出有至少两个危害，第一，会将其他数据段、代码段的内存空间覆盖，破坏其他的数据、指令；第二，溢出堆栈段的数据其安全性和完整性得不到保证，可能会被其他意外地修改。

C 程序的堆栈段并不会被保存在 elf 文件中，而是操作系统载入这个程序的时候自动分配的，但是这个堆栈的大小也是有限的，比如 1K 或者 1M ，但是不是可以无限制的增大的。

在这里我们可以明显感受到，为什么 for 循环的执行效率远高于递归了。递归函数在执行的时候，除了需要进行必要的指令计算和内存使用之外，还需要执行寄存器保护、返回地址保护、堆栈开辟、控制流跳转等额外的指令操作和内存使用，比直接 for 循环多了很多的时间、空间的开销。所以如果情况允许的话，使用 for 循环代替递归调用是一个更好的选择。这里也解释了为什么 inline 函数的执行效率高与普通函数。

### 函数传参扩展

#### 浮点数据类型

我们看到了整数变量是如何利用整型寄存器传参的，现在我们来看看浮点变量是如何进行函数调用时的参数传递的。我们编写一个简单的浮点程序，然后对比它的反汇编，得到如下的结果：

```
double add(double f1, double f2){
 628:	7179                	addi	sp,sp,-48
 62a:	f422                	sd	s0,40(sp)
 62c:	1800                	addi	s0,sp,48
 62e:	fca43c27          	fsd	fa0,-40(s0)
 632:	fcb43827          	fsd	fa1,-48(s0)
    double fsum = f1 + f2;
 636:	fd843707          	fld	fa4,-40(s0)
 63a:	fd043787          	fld	fa5,-48(s0)
 63e:	02f777d3          	fadd.d	fa5,fa4,fa5
 642:	fef43427          	fsd	fa5,-24(s0)
    return fsum;
 646:	fe843787          	fld	fa5,-24(s0)
}
 64a:	22f78553          	fmv.d	fa0,fa5
 64e:	7422                	ld	s0,40(sp)
 650:	6145                	addi	sp,sp,48
 652:	8082                	ret
```

我们可以看到这里使用的就是 fa0、fa1 传入参数，然后进行一系列的计算，计算完毕后计算结果保存到 fa0 中返回给调用方。riscv 的 32 个浮点寄存器被分为三组：fa0-fa7、fs0-fs11、ft0-ft11，它们的作用等价于 GPR 的 a0-a7、s0-s11、t0-t7。

#### 结构数据类型

我们定义一个简单的结构体 Pair：
```C
typedef struct pair{
    unsigned long long x;
    unsigned long long y;
} Pair;
```

然后执行`Pair p3 = add(p1, p2);`，观察 C 函数是如何将结构体作为参数传参，如何将结构体的返回值返回回来。

```
    Pair p1 = {1, 2};
 68c:	4785                	li	a5,1
 68e:	fcf43023          	sd	a5,-64(s0)
 692:	4789                	li	a5,2
 694:	fcf43423          	sd	a5,-56(s0)
    Pair p2 = {1, 2};
 698:	4785                	li	a5,1
 69a:	fcf43823          	sd	a5,-48(s0)
 69e:	4789                	li	a5,2
 6a0:	fcf43c23          	sd	a5,-40(s0)
    Pair p3 = add(p1, p2);
 6a4:	fd043603          	ld	a2,-48(s0)
 6a8:	fd843683          	ld	a3,-40(s0)
 6ac:	fc043503          	ld	a0,-64(s0)
 6b0:	fc843583          	ld	a1,-56(s0)
 6b4:	f75ff0ef          	jal	ra,628 <add>
 6b8:	872a                	mv	a4,a0
 6ba:	87ae                	mv	a5,a1
 6bc:	fee43023          	sd	a4,-32(s0)
 6c0:	fef43423          	sd	a5,-24(s0)
```

我们可以看到在这个函数中，结构体 p1 的成员 x、y 地址分别是`-64(s0)`和`-56(s0)`，而结构体 p2 的成员 x、y 地址分别是`-48(s0)`和`-40(s0)`。当函数进行传参的时候，可以看到内存 p1、p2 的成员所在的内存 -64(s0)、-56(s0)、-48(s0)、-40(s0) 分别被保存到了寄存器 a0、a1、a2、a3 当中，然后传入函数 add。因此一个结构体的内容会被多个 ax 寄存器保存，然后传递到函数当中。

当 add 函数返回结果时也可以看到是从 a0、a1 寄存器中的到结构体 pair 的结果。所以一个结构体的值也会被存到多个寄存器当中被返回。

#### 超过 a0-a7 范围

如果需要传参的参数个数超过了 8 个，或者说要传参的结构体们不能被 8 个寄存器完全装下，这个时候需要如何解决？

现在我们定义一个更复杂的结构 Pair：
```C
typedef struct pair{
    unsigned long long x;
    unsigned long long y;
    unsigned long long z;
    unsigned long long k;
} Pair;
```

然后执行函数
```C
Pair add(Pair p1, Pair p2, int x, int y, int z, int k);
```

我们可以看到两个结构体加上四个变量需要 12 个寄存器才可以完全传递数据，所以原来简单的 a 传参的方式就无法执行了。那么我们现在对着汇编代码来看看实际上是如何执行的。

```
    Pair p3 = add(p1, p2, 4, 5, 6, 7);
 7ec:	fc840513          	addi	a0,s0,-56
 7f0:	f8843603          	ld	a2,-120(s0)
 7f4:	f9043683          	ld	a3,-112(s0)
 7f8:	f9843703          	ld	a4,-104(s0)
 7fc:	fa043783          	ld	a5,-96(s0)
 800:	f6c43023          	sd	a2,-160(s0)
 804:	f6d43423          	sd	a3,-152(s0)
 808:	f6e43823          	sd	a4,-144(s0)
 80c:	f6f43c23          	sd	a5,-136(s0)
 810:	fa843603          	ld	a2,-88(s0)
 814:	fb043683          	ld	a3,-80(s0)
 818:	fb843703          	ld	a4,-72(s0)
 81c:	fc043783          	ld	a5,-64(s0)
 820:	f4c43023          	sd	a2,-192(s0)
 824:	f4d43423          	sd	a3,-184(s0)
 828:	f4e43823          	sd	a4,-176(s0)
 82c:	f4f43c23          	sd	a5,-168(s0)
 830:	f4040613          	addi	a2,s0,-192
 834:	f6040593          	addi	a1,s0,-160
 838:	481d                	li	a6,7
 83a:	4799                	li	a5,6
 83c:	4715                	li	a4,5
 83e:	4691                	li	a3,4
 840:	eb9ff0ef          	jal	ra,6f8 <add>
```

通过一定的分析可以推断出 -56(s0) 是 p3 结构在栈帧中的地址，所以 a0 寄存器的值就是返回值写入的结构在内存中的地址。对方的函数并不会将计算得到的结构体用 a0-7 的寄存器传递回来，而是会直接写入承接返回值的内存地址当中。这样可以省去将计算得到的结构体从内存写入寄存器，再从寄存器写入内存的过程，一步到位。既让参数传递变得更加方便简洁，又让程序执行的效率变得更快。
```
 7ec:	fc840513          	addi	a0,s0,-56
```

对于结构体 p1、p2 的传参，这里的过程也比较繁琐。首先我们一直 -120(s0)~-96(s0) 是 p2 的内存范围，而 -88(s0)~-64(s0) 是 p1 的内存范围。然后为了将这两个结构体传递到函数内，这里并不是用 a 寄存器传递完整的数据，而是传递两个结构的地址。如果这两个结构是 const 类型，不会再函数内部被修改，那么这样就足够了，但是因为不是 const 类型，他们是有可能被修改的。所以需要给这些数据准备新的内存地址，防止将调用函数中的结构的内容修改掉，于是在栈帧中的地址额外开辟了内存 -160(s0)~-136(s0) 和 -192(s0)~-168(s0) 作为对应的在被调用函数中 add 的局部变量 p1、p2，然后将本函数的 p1、p2 复制进去。最后将为 add 准备的局部变量 p1、p2 的地址存到 a1、a2 中传递进去。
```
 7f0:	f8843603          	ld	a2,-120(s0)
 7f4:	f9043683          	ld	a3,-112(s0)
 7f8:	f9843703          	ld	a4,-104(s0)
 7fc:	fa043783          	ld	a5,-96(s0)
 800:	f6c43023          	sd	a2,-160(s0)
 804:	f6d43423          	sd	a3,-152(s0)
 808:	f6e43823          	sd	a4,-144(s0)
 80c:	f6f43c23          	sd	a5,-136(s0)
 810:	fa843603          	ld	a2,-88(s0)
 814:	fb043683          	ld	a3,-80(s0)
 818:	fb843703          	ld	a4,-72(s0)
 81c:	fc043783          	ld	a5,-64(s0)
 820:	f4c43023          	sd	a2,-192(s0)
 824:	f4d43423          	sd	a3,-184(s0)
 828:	f4e43823          	sd	a4,-176(s0)
 82c:	f4f43c23          	sd	a5,-168(s0)
 830:	f4040613          	addi	a2,s0,-192
 834:	f6040593          	addi	a1,s0,-160
```

最后将是将剩下的基本类型参数存入后续的 a 寄存器，然后调用 add 函数执行即可。
```
 838:	481d                	li	a6,7
 83a:	4799                	li	a5,6
 83c:	4715                	li	a4,5
 83e:	4691                	li	a3,4
 840:	eb9ff0ef          	jal	ra,6f8 <add>
```

这里通过传入返回结构体地址、参数结构体地址的方法，将使用一组 a 寄存器传递一个结构体转换为用一个 a 寄存器传递一个结构体指针，解决了需要大量寄存器传递结构体的问题。

之后我们来看一下基本参数的个数超过 8 个的情况。调用函数：
```C
int add(int x0, int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8, int x9, int x10, int x11)
```
可以看到这里传递了 12 个参数，前面八个参数可以用寄存器 a0-a7 进行传递，那么后面四个参数要如何处理呢？在汇编中我们可以看到，多余的四个参数会被保存到对战的栈顶，0(sp)~24(sp) 的内存中。之后在 add 函数中会使用 0(fp)~24(fp) 来访问这些变量。
```
    int sum = add(1,2,3,4,5,6,7,8,9,10,11,12);
 6d4:	47b1                	li	a5,12
 6d6:	ec3e                	sd	a5,24(sp)
 6d8:	47ad                	li	a5,11
 6da:	e83e                	sd	a5,16(sp)
 6dc:	47a9                	li	a5,10
 6de:	e43e                	sd	a5,8(sp)
 6e0:	47a5                	li	a5,9
 6e2:	e03e                	sd	a5,0(sp)
```

因此我们可以看到多余的参数会通过堆栈进行传递，并且这些变量在堆栈当中可以直接获得局部变量的存储空间，而不需要向其他参数，那样进入被调用函数之后再在栈帧中存入对应局部变量内存。同时我们也可以看到一个函数的栈帧并不是只有她自己开辟的那一部分，还包括调用者在堆栈中传参使用的堆栈部分。这里简单总结一下，一个函数涉及到的栈帧从高地址向低地址可能包括：

* 调用函数为传参和返回值开辟的堆栈空间
* 保存 fp、ra、s0-s11 的堆栈空间
* 局部变量的堆栈空间
* 调用其他函数，为他们传递参数和接收返回值开辟堆栈空间







